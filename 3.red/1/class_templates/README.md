# Таблица

Вам надо написать шаблонный класс Table для электронной таблицы. Для простоты будем считать, что все ячейки таблицы имеют один и тот же тип данных T. Таблица должна уметь менять свой размер по требованию пользователя. Вновь созданные ячейки должны заполняться значениями по умолчанию типа T.

Требования к классу такие:
* Класс должен называться Table.
* У класса должен быть шаблонный параметр T — тип элемента в ячейке.
* У класса должен быть конструктор, получающий на входе два числа типа size_t — количество строк и столбцов соответственно.
* У класса должны быть константная и неконстантная версии оператора [], возвращающего нечто такое, к чему снова можно было бы применить оператор []. То есть, должны работать конструкции вида cout << table[i][j];и table[i][j] = value;. Проверять корректность индексов при этом не нужно.
* У класса должна быть функция Resize, получающая на вход два параметра типа size_t и меняющая размер таблицы. Старые данные, умещающиеся в новый размер, должны при этом сохраниться.
* У класса должна быть константная функция Size, возвращающая pair<size_t, size_t> — размер таблицы (в том же порядке, в котором эти аргументы передавались в конструктор). При этом, если у таблицы Table один из размеров нулевой, то необходимо считать таковым и второй размер таблицы.

## Решение
    table.cpp

# Дек на основе двух векторов

Напишите шаблонный класс Deque, содержащий следующий набор методов:
* конструктор по умолчанию;
* константный метод Empty, возвращающий true, если дек не содержит ни одного элемента;
* константный метод Size, возвращающий количество элементов в деке;
* T& operator[](size_t index) и const T& operator[](size_t index) const;
* константный и неконстантный метод At(size_t index), генерирующий стандартное исключение out_of_range, если индекс больше или равен количеству элементов в деке;
* константные и неконстантные версии методов Front и Back, возвращающих ссылки на первый и последний элемент дека соответственно;
* методы PushFront и PushBack.

Неконстантные версии методов должны позволять изменять соответствующий элемент дека.

## Решение
    deque_via_two_vectors.cpp

# Шаблон Paginator

В лекции мы разработали функцию Head, которая позволяет пройтись циклом for по началу контейнера. В этой задаче мы сделаем шаг вперёд и разработаем шаблон Paginator, который разбивает содержимое контейнера на несколько страниц. Классический пример, когда такое может пригодиться на практике, — это распределение списка мобильных приложений по экранам телефона. Допустим, у нас есть вектор всех приложений нашего телефона и на одном экране мы можем разместить 20 иконок приложений. Тогда распределить приложения по экранам мы можем вот таким кодом:

```cpp
vector<vector<Application>> DistributeAmongScreens(const vector<Application>& apps) {
  vector<vector<Application>> result;
  for (const auto& page : Paginate(apps, 20)) {
    result.push_back({page.begin(), page.end()});
  }
  // result[0] - все приложения, которые попадают на первый экран,
  // result[1] - все приложения, которые попадают на второй экран и т.д.
  return result;
}
```
Заметьте, наш код получился коротким и элегантным. Нам не пришлось писать какой-то отдельный код для обработки последнего экрана, который может содержать меньше 20 приложений.

Итак, разработайте шаблон класса Paginator со следующими свойствами:  
* он имеет один шаблонный параметр — тип итератора
* конструктор класса Paginator<Iterator> принимает три параметра: 
1. Iterator begin 
2. Iterator end — пара итераторов begin и end задают полуинтервал [begin; end), который мы будем нарезать на страницы 
3. size_t page_size — размер одной страницы
* по объектам класса Paginator<Iterator> можно проитерироваться с помощью цикла range-based for 
* класс Paginator<Iterator> имеет метод size_t size() const, который возвращает количество страниц, на которые был разбит переданный контейнер 
* сами страницы должны так же поддерживать итерацию с помощью range-based for и иметь метод size_t size() const, возвращающий количество объектов в этой странице 
* подробные примеры использования смотрите в юнит-тестах в шаблоне решения

Кроме того разработайте шаблон функции Paginate, которая принимает ссылку на контейнер и размер страницы, и возвращает объект класса Paginator<It>: 

```cpp
template <typename C> ??? Paginate(C& c, size_t page_size)
```

## Решение
    paginator.cpp

