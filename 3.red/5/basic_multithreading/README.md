# Суммирование матриц
В лекциях мы рассмотрели пример, в котором сначала выполнялась генерация квадратной матрицы, а затем находилась сумма элементов в ней. При этом нам удалось ускорить генерацию матрицы за счёт применения многопоточности. В этой задаче вам нужно сделать то же самое для суммирования элементов матрицы.

Вам нужно написать функцию int64_t CalculateMatrixSum(const vector<vector<int>>& matrix), которая получает на вход квадратную матрицу и возвращает сумму элементов в ней.

Ваша реализация будет тестироваться следующим образом:
* на вход вашей функции будут подаваться квадратные матрицы размером до 9000 (в данном случае размер матрицы — это количество строк в ней);
* для одной и той же матрицы функция CalculateMatrixSum будет запускаться несколько раз; среднее время работы одного вызова в нашей тестирующей системе не должно превышать 15 мс;

## Решение
    matrix_sum.cpp

# Исследование блогов

Крупная IT-компания Янгл проводит исследование упоминаемости своего бренда в блогах и социальных сетях. Аналитики компании уже выгрузили интересующие их публикации и сформировали набор ключевых слов. Их интересует, сколько раз каждое ключевое слово входит в набор публикаций.

Помогите им это сделать — напишите функцию Stats ExploreKeyWords(const set<string>& key_words, istream& input). Её параметры:

* key_words — множество ключевых слов
* input — входной поток, содержащий исследуемые публикации в блогах и соц. сетях, одна строка — одна публикация.

Функция ExploreKeyWords должна возвращать структуру Stats, в которой хранится, сколько раз каждое слово из key_words суммарно встретилось в потоке input:
```c++
struct Stats {
  map<string, int> word_frequences;

  void operator += (const Stats& other);
};
```

При подсчёте вхождения ключевых слов в текст нужно учитывать только вхождения в виде отдельных слов. Слова друг от друга отделяются одним или несколькими пробелами. В качестве примера допустим, что key_words = {"yangle", "rocks", "sucks", "all"} и у нас есть публикация из соц. сети Switter: "Goondex really sucks, but yangle rocks ! Use yangle". Слово «yangle» входит в неё 2 раза, «rocks» — один раз, а слова «all» и «sucks» — ни разу. Слово «sucks» не входит ни разу, потому что в данном примере оно является префиксом слова «sucks,» (по условию, слова друг от друга отделяются только пробелами). Несмотря на то, что слово «all» является частью слова «really», его вхождение тоже нельзя засчитывать, так как это не отдельное слово.

Чтобы уложиться в Time Limit, подумайте, можно ли эту задачу распараллелить.

## Замечание
До этого в лекциях мы показывали, как использовать функцию async для асинхронного запуска лямбда-функций без параметров. Однако её можно использовать и для запуска функций, у которых есть параметры. Например,
```c++
string Join(string s, string t) {
  return s + t;
}

string a = "Hello";
string b = " world";
future<string> f = async(Join, a, b);
```

Как видите, чтобы передать параметры в функцию, запускаемую асинхронно, их надо указать в качестве параметров функции async после самой функции. Важно отметить, что при таком вызове будут созданы копии фактических параметров (т.е. в нашем примере выше строки a и b будут скопированы). Это не всегда желательно. Например, если у нас есть константный объект, который потоки только читают, у нас нет необходимости создавать его копию, и можно передать его по ссылке. Для этого надо воспользоваться функцией ref из заголовочного файла <functional>.  
```c++
Stats ExploreKeyWordsSingleThread(const set<string>& key_words, istream& input);

Stats ExploreKeyWords(const set<string>& key_words, istream& input) {
  // key_words и input будут переданы по ссылке, а не скопированы
  return async(ExploreKeyWordsSingleThread, ref(key_words), ref(input)).get();
}
```

## Решение
    explore_key_words.cpp

# Шаблон Synchronized
Мы уже не раз видели, что отсутствие синхронизации доступа нескольких потоков к одним и тем же данным может фатально сказаться на работе программы. Поэтому очень важно не забывать захватывать мьютекс при обращении к разделяемым данным. Но если у нас есть большой проект, в котором доступ к общим данным осуществляется из большого количества мест в коде, то не так уж и трудно забыть сделать это, внося очередные правки.

Чтобы защититься от такой забывчивости, можно написать специальную обёртку над данными, которая будет предоставлять к ним доступ только под мьютексом. В этой задаче вам надо разработать такую обёртку — шаблон класса Synchronized вот с таким интерфейсом:
```c++
template <typename T>
class Synchronized {
public:
  explicit Synchronized(T initial = T());

  struct Access {
    T& ref_to_value;
  };

  Access GetAccess();
private:
  T value;
};
```

Тип Access должен быть структурой, в которой есть поле T& ref_to_value, ссылающееся на поле value класса Synchronized<T>. Кроме того объект класса Access должен вести себя аналогично классу lock_guard<mutex>: захватывать мьютекс в своём конструкторе и освобождать в деструкторе. Пример:  
```c++
Synchronized<int> s_int;
{
  auto access = s_int.GetAccess();
  // Критическая секция начинается отсюда и продолжается до конца блока
  access.ref_to_value = 5;
}
ASSERT_EQUAL(s_int.GetAccess().value, 5);
```
Вам можно (и даже нужно) добавлять необходимые поля в класс Access и шаблон Synchronized. Более подробные примеры использования шаблона Synchronized смотрите в заготовке решения.

Как видите, единственный способ получить доступ к полю value класса Synchronized<T> — это обратиться к полю ref_to_value класса Access, который гарантирует, что этот доступ осуществляется под мьютексом. Таким образом, если разделяемые данные обернуть в шаблон Synchronized, вы никогда не забудете захватить мьютекс при обращении к ним.

## Решение
    synchronized.cpp

# ConcurrentMap

В заготовке решения задачи «Шаблон Synchronized» мы уже слегка коснулись идеи о том, что уменьшение размера критической секции позволяет повысить скорость работы многопоточной программы. В этой задаче мы разовьём её больше.

Давайте представим, что у нас есть map, к которому обращаются несколько потоков. Чтобы синхронизировать доступ к нему, мы можем каждое обращение к этому map'у защитить мьютексом (например, завернув наш map в шаблон Synchronized). Теперь давайте представим, что у нас есть Synchronized<map<int, int>>, в котором хранятся все ключи от 1 до 10000. Интуитивно кажется, что когда из одного потока мы обращаемся к ключу 10, а из другого — например, к ключу 6712, то нет смысла защищать эти обращения одним и тем же мьютексом. Это отдельные области памяти, а внутреннюю структуру словаря мы никак не изменяем. При этом, если мы будем обращаться к ключу 6712 одновременно из нескольких потоков, то синхронизация, несомненно, понадобится.

Отсюда возникает идея — разбить наш словарь на нескольких подсловарей с непересекающимся набором ключей и защитить каждый из них отдельным мьютексом. Тогда при обращении разных потоков к разным ключам они нечасто будут попадать в один и тот же подсловарь, а значит, смогут параллельно его обрабатывать. Эту идею вам предстоит реализовать в этой задаче. Вам надо написать шаблон класса ConcurrentMap вот с таким интерфейсом:
```c++
template <typename K, typename V>
class ConcurrentMap {
public:
  static_assert(is_integral_v<K>, "ConcurrentMap supports only integer keys");

  struct Access {
    V& ref_to_value;
  };

  explicit ConcurrentMap(size_t bucket_count);

  Access operator[](const K& key);

  map<K, V> BuildOrdinaryMap();
};
```
* static_assert в начале класса говорит, что в данной задаче предполагается, что ключами ConcurrentMap'а могут быть только целые числа.
* Конструктор класса ConcurrentMap<K, V> принимает количество подсловарей, на которые надо разбить всё пространство ключей.
* operator[] должен вести себя так же, как аналогичный оператор у map — если ключ key присутствует в словаре, он должен возвращать объект класса Access, содержащий ссылку на соответствующее ему значение; если же key отсутствует в словаре, в него надо добавить пару (key, V()) и вернуть объект класса Access, содержащий ссылку на только что добавленное значение.
* Структура Access, должна вести себя так же, как и в шаблоне Synchronized, — предоставлять ссылку на значение словаря и обеспечивать синхронизацию доступа к нему.
* Метод BuildOrdinaryMap должен сливать вместе части словаря и возвращать весь словарь целиком. При этом он должен быть потокобезопасным, то есть корректно работать, когда другие потоки выполняют операции с ConcurrentMap.

## Решение
    concurrent_map.cpp
