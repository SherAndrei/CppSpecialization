# Считалка Иосифа

Дан диапазон объектов некоторого типа. Напишите функцию, переставляющую его элементы в соответствии с порядком, определённым так называемой считалкой Иосифа с заданным размером шага:  

```cpp
template <typename RandomIt>
void MakeJosephusPermutation(
    RandomIt range_begin, RandomIt range_end,
    uint32_t step_size
);
```

Гарантируется, что итераторы range_begin и range_end являются итераторами произвольного доступа, то есть допускают вычитание одного из другого и сложение с числом. Кроме того, вы можете полагаться на то, что step_size > 0. Тип переупорядочиваемых объектов можно получить с помощью выражения typename RandomIt::value_type. Объекты этого типа запрещено копировать. При наличии копирования этих объектов вы получите ошибку компиляции.

### Решение
 josephus_permutation.cpp

# Группировка строк

Дан набор строк. Необходимо разбить их на группы, в каждой из которых все строки имеют одинаковый набор символов.

Например, если даны строки law, port, top, laptop, pot, paloalto, wall, awl, нужно разбить их на 4 группы:

* строки, состоящие только из букв a, l и w: law, wall, awl;
* строки, состоящие только из букв o, p, r и t: port;
* строки, состоящие только из букв o, p и t: top, pot;
* строки, состоящие только из букв a, l, o, p, t: laptop, paloalto.

Разбиение на группы должно быть реализовано в виде функции

```cpp
template <typename String>
using Group = vector<String>;

template <typename String>
vector<Group<String>> GroupHeavyStrings(vector<String> strings);
```

Наличие такого синонима позволяет записать возвращаемый тип функции GroupHeavyString в виде vector<Group<String>>, что читается понятнее, чем vector<vector<String>>.

Слова в каждой группе должны располагаться в том же порядке, что и в исходном наборе. При этом порядок самих групп значения не имеет.

Строка типа String не обязана состоять из символов типа char. Тип символа можно получить с помощью выражения typename String::value_type или Char<String>, если определить соответствующий синоним:

```cpp
template <typename String>
using Char = typename String::value_type;
```
Сам тип String может быть, например, обычной строкой (string) или вектором символов.

Про тип Char<String> известно следующее:

* Объекты этого типа можно сравнивать с помощью операторов == и <.
* «Тяжёлыми» могут быть не только сами строки, но и отдельные символы. Поэтому их можно свободно перемещать, но скопировать каждый символ в функции можно не более одного раза (без учёта копирования при передаче аргумента strings по значению). В противном случае вы получите вердикт «неправильный ответ» с соответствующим комментарием.

### Решение
 group_heavy_string.cpp


# Оператор присваивания для SimpleVector

В видеолекции мы с вами познакомились с конструктором копирования и оператором присваивания, а также написали конструктор копирования для SimpleVector. В этой задаче вам нужно реализовать оператор присваивания для SimpleVector.

Напомним, что следующий код вызывает конструктор копирования:

```cpp
SimpleVector<int> source(5);
SimpleVector<int> dest = source; // Конструктор копирования
```

А код ниже — оператор присваивания:

```cpp
SimpleVector<int> source(5);
SimpleVector<int> dest;
dest = source; // Оператор присваивания
```

### Решение
 simple_vector/1/


# Разбиение на предложения

Дан вектор токенов. Напишите функцию, разбивающую токены на предложения: 

```cpp
template <typename Token>
vector<Sentence<Token>> SplitIntoSentences(vector<Token> tokens);
```

Token — шаблонный тип, про который известно лишь то, что он имеет константный метод IsEndSentencePunctuation, возвращающий true, если токен является знаком пунктуации, заканчивающим предложение, и false в противном случае. Объекты этого типа запрещено копировать. При наличии копирования этих объектов вы получите ошибку компиляции.

Sentence — синоним для типа vector, объявленный следующим образом:

```cpp
// Объявляем Sentence<Token> для произвольного типа Token
// синонимом vector<Token>.
// Благодаря этому в качестве возвращаемого значения
// функции можно указать не малопонятный вектор векторов,
// а вектор предложений — vector<Sentence<Token>>.
template <typename Token>
using Sentence = vector<Token>;
```
Предложением считается последовательность токенов, заканчивающаяся подряд идущими токенами, являющимися знаками пунктуации конца предложения. Иными словами, любое предложение должно состоять из двух частей:

* токены, для которых IsEndSentencePunctuation возвращает false (такие токены обязаны присутствовать в предложении за исключением, возможно, первого предложения);
* токены, для которых IsEndSentencePunctuation возвращает true (такие токены обязаны присутствовать в предложении за исключением, возможно, последнего предложения).

### Решение
 split_into_sentences.cpp

# Move-семантика в SimpleVector

Решите задачу «Реализовать свой вектор» со следующими дополнительными требованиями:
* метод PushBack должен позволять добавить элемент в вектор с помощью перемещения;
* никакие методы вектора не должны осуществлять копирование элементов.

Таким образом, должен получиться вектор, позволяющий хранить некопируемые объекты.

### Решение
 simple_vector/2/

# Сортировка слиянием — 3

Напишите шаблонную функцию MergeSort, принимающую два итератора шаблонного типа RandomIt и сортирующую заданный ими диапазон с помощью сортировки слиянием. Гарантируется, что:
* итераторы типа RandomIt аналогичны по функциональности итераторам вектора и строки, то есть их можно сравнивать с помощью операторов <, <=, > и >=, а также вычитать и складывать с числами;
* сортируемые объекты можно сравнивать с помощью оператора <.

```cpp
template <typename RandomIt>
void MergeSort(RandomIt range_begin, RandomIt range_end);
```

### Решение
 merge_sort_3.cpp

