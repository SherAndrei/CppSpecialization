# Считалка Иосифа

Дан диапазон объектов некоторого типа. Напишите функцию, переставляющую его элементы в соответствии с порядком, определённым так называемой считалкой Иосифа с заданным размером шага:  

```cpp
template <typename RandomIt>
void MakeJosephusPermutation(
    RandomIt range_begin, RandomIt range_end,
    uint32_t step_size
);
```

Гарантируется, что итераторы range_begin и range_end являются итераторами произвольного доступа, то есть допускают вычитание одного из другого и сложение с числом. Кроме того, вы можете полагаться на то, что step_size > 0. Тип переупорядочиваемых объектов можно получить с помощью выражения typename RandomIt::value_type. Объекты этого типа запрещено копировать. При наличии копирования этих объектов вы получите ошибку компиляции.

## Решение
 josephus_permutation.cpp

# Группировка строк

Дан набор строк. Необходимо разбить их на группы, в каждой из которых все строки имеют одинаковый набор символов.

Например, если даны строки law, port, top, laptop, pot, paloalto, wall, awl, нужно разбить их на 4 группы:

* строки, состоящие только из букв a, l и w: law, wall, awl;
* строки, состоящие только из букв o, p, r и t: port;
* строки, состоящие только из букв o, p и t: top, pot;
* строки, состоящие только из букв a, l, o, p, t: laptop, paloalto.

Разбиение на группы должно быть реализовано в виде функции

```cpp
template <typename String>
using Group = vector<String>;

template <typename String>
vector<Group<String>> GroupHeavyStrings(vector<String> strings);
```

Наличие такого синонима позволяет записать возвращаемый тип функции GroupHeavyString в виде vector<Group<String>>, что читается понятнее, чем vector<vector<String>>.

Слова в каждой группе должны располагаться в том же порядке, что и в исходном наборе. При этом порядок самих групп значения не имеет.

Строка типа String не обязана состоять из символов типа char. Тип символа можно получить с помощью выражения typename String::value_type или Char<String>, если определить соответствующий синоним:

```cpp
template <typename String>
using Char = typename String::value_type;
```
Сам тип String может быть, например, обычной строкой (string) или вектором символов.

Про тип Char<String> известно следующее:

* Объекты этого типа можно сравнивать с помощью операторов == и <.
* «Тяжёлыми» могут быть не только сами строки, но и отдельные символы. Поэтому их можно свободно перемещать, но скопировать каждый символ в функции можно не более одного раза (без учёта копирования при передаче аргумента strings по значению). В противном случае вы получите вердикт «неправильный ответ» с соответствующим комментарием.

## Решение
 group_heavy_string.cpp

# Оператор присваивания для SimpleVector

В видеолекции мы с вами познакомились с конструктором копирования и оператором присваивания, а также написали конструктор копирования для SimpleVector. В этой задаче вам нужно реализовать оператор присваивания для SimpleVector.

Напомним, что следующий код вызывает конструктор копирования:

```cpp
SimpleVector<int> source(5);
SimpleVector<int> dest = source; // Конструктор копирования
```

А код ниже — оператор присваивания:

```cpp
SimpleVector<int> source(5);
SimpleVector<int> dest;
dest = source; // Оператор присваивания
```

## Решение
 simple_vector/1/

# Разбиение на предложения

Дан вектор токенов. Напишите функцию, разбивающую токены на предложения: 

```cpp
template <typename Token>
vector<Sentence<Token>> SplitIntoSentences(vector<Token> tokens);
```

Token — шаблонный тип, про который известно лишь то, что он имеет константный метод IsEndSentencePunctuation, возвращающий true, если токен является знаком пунктуации, заканчивающим предложение, и false в противном случае. Объекты этого типа запрещено копировать. При наличии копирования этих объектов вы получите ошибку компиляции.

Sentence — синоним для типа vector, объявленный следующим образом:

```cpp
// Объявляем Sentence<Token> для произвольного типа Token
// синонимом vector<Token>.
// Благодаря этому в качестве возвращаемого значения
// функции можно указать не малопонятный вектор векторов,
// а вектор предложений — vector<Sentence<Token>>.
template <typename Token>
using Sentence = vector<Token>;
```
Предложением считается последовательность токенов, заканчивающаяся подряд идущими токенами, являющимися знаками пунктуации конца предложения. Иными словами, любое предложение должно состоять из двух частей:

* токены, для которых IsEndSentencePunctuation возвращает false (такие токены обязаны присутствовать в предложении за исключением, возможно, первого предложения);
* токены, для которых IsEndSentencePunctuation возвращает true (такие токены обязаны присутствовать в предложении за исключением, возможно, последнего предложения).

## Решение
 split_into_sentences.cpp

# Move-семантика в SimpleVector

Решите задачу «Реализовать свой вектор» со следующими дополнительными требованиями:
* метод PushBack должен позволять добавить элемент в вектор с помощью перемещения;
* никакие методы вектора не должны осуществлять копирование элементов.

Таким образом, должен получиться вектор, позволяющий хранить некопируемые объекты.

## Решение
 simple_vector/2/

# Сортировка слиянием — 3

Напишите шаблонную функцию MergeSort, принимающую два итератора шаблонного типа RandomIt и сортирующую заданный ими диапазон с помощью сортировки слиянием. Гарантируется, что:
* итераторы типа RandomIt аналогичны по функциональности итераторам вектора и строки, то есть их можно сравнивать с помощью операторов <, <=, > и >=, а также вычитать и складывать с числами;
* сортируемые объекты можно сравнивать с помощью оператора <.

```cpp
template <typename RandomIt>
void MergeSort(RandomIt range_begin, RandomIt range_end);
```

## Решение
 merge_sort_3.cpp

# Контейнер с приоритетами

## Условие задачи

Реализуйте шаблонный контейнер PriorityCollection, позволяющий хранить объекты некопируемого типа, а также совершать с ними следующие операции:
* добавить элемент с нулевым приоритетом;
* добавить набор элементов с нулевыми приоритетами;
* увеличить на 1 приоритет заданного элемента;
* извлечь из контейнера элемент с максимальным приоритетом.

Поскольку добавление элемента заключается в его перемещении в контейнер, метод увеличения приоритета не может принимать сам элемент. Поэтому метод, добавляющий элементы, для каждого из них должен вернуть некий идентификатор, который затем можно использовать для вызова других методов.

Тип идентификатора — PriorityCollection::Id — вы должны выбрать самостоятельно. Он должен быть легко копируемым: например, числом, указателем или итератором. Примеры определения и использования типа Id вы можете найти в шаблоне решения.

## Структура класса
```c++
template <typename T>
class PriorityCollection {
public:
  using Id = /* тип, используемый для идентификаторов */;

  // Добавить объект с нулевым приоритетом
  // с помощью перемещения и вернуть его идентификатор
  Id Add(T object);

  // Добавить все элементы диапазона [range_begin, range_end)
  // с помощью перемещения, записав выданные им идентификаторы
  // в диапазон [ids_begin, ...)
  template <typename ObjInputIt, typename IdOutputIt>
  void Add(ObjInputIt range_begin, ObjInputIt range_end,
           IdOutputIt ids_begin);

  // Определить, принадлежит ли идентификатор какому-либо
  // хранящемуся в контейнере объекту
  bool IsValid(Id id) const;

  // Получить объект по идентификатору
  const T& Get(Id id) const;

  // Увеличить приоритет объекта на 1
  void Promote(Id id);

  // Получить объект с максимальным приоритетом и его приоритет
  pair<const T&, int> GetMax() const;

  // Аналогично GetMax, но удаляет элемент из контейнера
  pair<T, int> PopMax();

private:
  // Приватные поля и методы
};
```

## Гарантии
* Вы можете полагаться на то, что для элементов типа T определены перемещение и сравнение на ==, != и <. Все операции над элементами имеют константную сложность.
* Гарантируется, что все добавляемые элементы различны, однако добавленный и затем извлечённый элемент может быть добавлен вновь.
* Методы Get и Promote всегда вызываются от валидных с точки зрения метода IsValid идентификаторов.
* Методы GetMax и PopMax вызываются только при наличии элементов в контейнере.
* При наличии нескольких элементов с одинаковым максимальным приоритетом необходимо выбирать и извлекать тот, который был добавлен позже остальных.

## Решение
    priority_collection_2.cpp
